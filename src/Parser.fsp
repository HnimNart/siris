
%{

let p0 = (0,0)

open Microsoft.FSharp.Text.Parsing
open AbSyn

(* parse-error function *)
let mutable ErrorContextDescriptor : string = ""

let parse_error_rich =
  Some (fun (ctxt: ParseErrorContext<_>) ->
    ErrorContextDescriptor <-
      match ctxt.CurrentToken with
      | None -> "At beginning of input\n"
      | Some token -> sprintf "at token %A\n" token
  )

%}

%token <int*(int*int)> NUM
%token <string*(int*int)> ID VAR
%token <(int*int)> IF THEN ELSE FI
%token <(int*int)> UNTIL REPEAT
%token <(int*int)> SWAP LOCAL DELOCAL
%token <(int*int)> CALL UNCALL
%token <(int*int)> PROCEDURE END
%token <(int*int)> INT
%token <(int*int)> VARDEC LBRACKET RBRACKET GLOBAL
%token <(int*int)> PLUS MINUS MULT DIV MOD
%token <(int*int)> CEQ LTH OR EQ
%token <(int*int)> LPAR RPAR SEMIC EOF
%token <(int*int)> LCURLY RCURLY COMMA
%token <(int*int)> READ PRINT
%token <(int*int)> PASSIGN MASSIGN

%nonassoc whileprec ifprec
%nonassoc OR
%left CEQ LTH
%left PLUS MINUS
%left MULT DIV MOD

%start Prog
%type <AbSyn.UntypedProg> Prog
%type <AbSyn.UntypedProcDec List> Procs
%type <AbSyn.UntypedProcDec> Proc
%type <AbSyn.UntypedStatement List> Statements
%type <AbSyn.UntypedStatement> Statement
%type <AbSyn.UntypedExp> Exp
%type <AbSyn.Type> Type

%%

Prog      : Declarations Statements Procs  { $1, $2, $3}
;

Declarations: VAR COMMA Declarations
                               { Declaration (fst $1, snd $1) ::  $3 }
            | VAR SEMIC        { Declaration (fst $1, snd $1) :: []}
            | SEMIC            { [] }
;


Procs     : PROCEDURE Proc  Procs  { $2 :: $3 }
          | PROCEDURE Proc         { $2 :: [] }
          | EOF                    { [] }
;

Proc      : ID LPAR Params RPAR Statements END
                                                    { ProcDec (fst $1, $3,  $5, snd $1) }
          | ID LPAR RPAR Statements END
                                                    { ProcDec (fst $1, [], $4 , snd $1)}
;

Params    : VAR COMMA Params { Param (fst $1) :: $3}
          | VAR              { Param (fst $1) :: []}
;


Statements : Statement SEMIC Statements {$1 :: $3}
           | Statement                  {$1 :: []}
           |                            { [] }
;

Statement : VAR PASSIGN Exp
                  { PlusAssignment ((fst $1), $3, $2) }
          | VAR MASSIGN Exp
                  { MinusAssignment ((fst $1), $3, $2) }
          | IF LPAR Exp RPAR THEN LCURLY Statements RCURLY ELSE LCURLY Statements RCURLY FI LPAR Exp RPAR
                  { If ($3, $7, $11, $15 , $1) }
          | REPEAT LCURLY Statements RCURLY UNTIL LPAR Exp RPAR
                  { Repeat ($3, $7, $1)}
          | CALL ID LPAR Params RPAR
                  { Call (fst $2, $4, $1)}
          | CALL ID LPAR RPAR
                  { Call (fst $2, [], $1)}
          | UNCALL ID LPAR Params RPAR
                  { Uncall (fst $2, $4, $1)}
          | UNCALL ID LPAR RPAR
                  { Uncall (fst $2, [], $1)}
          | PRINT LPAR VAR RPAR
                  { Print (fst $3, $1)}
          | READ LPAR VAR RPAR
                  { Read (fst $3, $1)}
          | LOCAL VAR EQ Exp
                   { Local (fst $2, $4, $1)}
          | DELOCAL VAR EQ Exp
                   { Delocal (fst $2, $4, $1)}
          | VAR SWAP VAR
                   { Swap (fst $1, fst $3, $2)}
;

Type      : INT        { AbSyn.Int }
;


Exp : NUM            { Constant (IntVal (fst $1), snd $1) }
    | VAR            { Var $1 }
    | Exp PLUS  Exp  { Plus ($1, $3, $2)    }
    | Exp MINUS Exp  { Minus($1, $3, $2)    }
    | Exp MULT  Exp  { Times($1, $3, $2)    }
    | Exp DIV   Exp  { Divide($1, $3, $2)   }
    | Exp MOD   Exp  { Modulo($1, $3, $2)   }
    | Exp CEQ   Exp  { Equal ($1, $3, $2)   }
    | Exp OR    Exp  { Or ($1, $3, $2)      }
    | Exp LTH   Exp  { Less ($1, $3, $2)    }
    | LPAR Exp RPAR  { $2 }
;

%%
